<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Griffin.Networking</name>
    </assembly>
    <members>
        <member name="T:Griffin.Networking.Buffers.BufferSlice">
            <summary>
            A slice of an larger buffer.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.IBufferSlice">
            <summary>
            We are a part of a larger buffer
            </summary>
            <remarks>It's important that you check if a buffer implement <code>IDisposable</code> since you then have
            to invoke <c>Dispose()</c> when done to return the buffer to the pool.</remarks>
        </member>
        <member name="P:Griffin.Networking.Buffers.IBufferSlice.Buffer">
            <summary>
            Gets buffer that we are a part of
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.IBufferSlice.Offset">
            <summary>
            Gets start index for this slice
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.IBufferSlice.Count">
            <summary>
            Number of bytes allocated for this slice.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferSlice.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.BufferSlice"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">Where our slice starts.</param>
            <param name="count">Number of bytes in our slice.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferSlice.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.BufferSlice"/> class.
            </summary>
            <param name="count">Number of bytes.</param>
            <remarks>Allocates a new buffer</remarks>
        </member>
        <member name="P:Griffin.Networking.Buffers.BufferSlice.Buffer">
            <summary>
            Gets buffer that the slice is in
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.BufferSlice.Offset">
            <summary>
            Gets offset for our slice
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.BufferSlice.Count">
            <summary>
            Gets the number of bytes that our slice has.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.StringBufferSliceReader">
            <summary>
            Read text from a buffer slice.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.IStringBufferReader">
            <summary>
            Reads a buffer as a string
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.Consume">
            <summary>
            Consume current character.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.Consume(System.Char[])">
            <summary>
            Consume specified characters
            </summary>
            <param name="chars">One or more characters.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ConsumeUntil(System.Char)">
            <summary>
            Consume all characters until the specified one have been found.
            </summary>
            <param name="delimiter">Stop when the current character is this one</param>
            <returns>New offset.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ConsumeWhiteSpaces">
            <summary>
            Consumes horizontal white spaces (space and tab).
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ConsumeWhiteSpaces(System.Char)">
            <summary>
            Consume horizontal white spaces and the specified character.
            </summary>
            <param name="extraCharacter">Extra character to consume</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.Contains(System.Char)">
            <summary>
            Checks if one of the remaining bytes are a specified character.
            </summary>
            <param name="ch">Character to find.</param>
            <returns>
            	<c>true</c> if found; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.Read">
            <summary>
            Read a character.
            </summary>
            <returns>
            Character if not EOF; otherwise <c>null</c>.
            </returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadLine">
            <summary>
            Get a text line. 
            </summary>
            <returns></returns>
            <remarks>Will merge multi line headers and rewind of end of line was not found.</remarks> 
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadQuotedString">
            <summary>
            Read quoted string
            </summary>
            <returns>string if current character (in buffer) is a quote; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadToEnd(System.String)">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>
            A string (can be <see cref="F:System.String.Empty"/>).
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadToEnd">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadToEnd(System.Char)">
            <summary>
            Read to end of buffer, or until specified delimiter is found.
            </summary>
            <param name="delimiter">Delimiter to find.</param>
            <returns>
            A string (can be <see cref="F:System.String.Empty"/>).
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadUntil(System.Char)">
            <summary>
            Will read until specified delimiter is found.
            </summary>
            <param name="delimiter">Character to stop at.</param>
            <returns>
            A string if the delimiter was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will trim away spaces and tabs from the end.</remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadUntil(System.String)">
            <summary>
            Read until one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>
            A string if one of the delimiters was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.ReadWord">
            <summary>
            Read until a horizontal white space occurs.
            </summary>
            <returns>A string if a white space was found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.IStringBufferReader.Assign(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Assigns the slice to read from
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="count"> </param>
        </member>
        <member name="P:Griffin.Networking.Buffers.IStringBufferReader.Current">
            <summary>
            Gets current character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:Griffin.Networking.Buffers.IStringBufferReader.HasMore">
            <summary>
            Gets if more bytes can be processed.
            </summary>
            <value></value>
        </member>
        <member name="P:Griffin.Networking.Buffers.IStringBufferReader.Index">
            <summary>
            Gets or sets current position in buffer.
            </summary>
            <remarks>
            THINK before you manually change the position since it can blow up
            the whole parsing in your face.
            </remarks>
        </member>
        <member name="P:Griffin.Networking.Buffers.IStringBufferReader.Length">
            <summary>
            Gets total length of buffer.
            </summary>
            <value></value>
        </member>
        <member name="P:Griffin.Networking.Buffers.IStringBufferReader.Peek">
            <summary>
            Gets next character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:Griffin.Networking.Buffers.IStringBufferReader.RemainingLength">
            <summary>
            Gets number of bytes left.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.StringBufferSliceReader"/> class.
            </summary>
            <remarks>You must use <see cref="M:Griffin.Networking.Buffers.StringBufferSliceReader.Assign(Griffin.Networking.Buffers.IBufferSlice,System.Int32)"/> if you use this constructor<para>Initialied using ASCII as encoding.</para></remarks>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.#ctor(System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.StringBufferSliceReader"/> class.
            </summary>
            <param name="encoding">Encoding to use when converting byte array to strings.</param>
            <remarks>You must use <see cref="M:Griffin.Networking.Buffers.StringBufferSliceReader.Assign(Griffin.Networking.Buffers.IBufferSlice,System.Int32)"/> if you use this constructor</remarks>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.#ctor(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.StringBufferSliceReader"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.Consume">
            <summary>
            Consume current character.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.Consume(System.Char[])">
            <summary>
            Consume specified characters
            </summary>
            <param name="chars">One or more characters.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ConsumeUntil(System.Char)">
            <summary>
            Consume all characters until the specified one have been found.
            </summary>
            <param name="delimiter">Stop when the current character is this one</param>
            <returns>New offset.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ConsumeWhiteSpaces">
            <summary>
            Consumes horizontal white spaces (space and tab).
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ConsumeWhiteSpaces(System.Char)">
            <summary>
            Consume horizontal white spaces and the specified character.
            </summary>
            <param name="extraCharacter">Extra character to consume</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.Contains(System.Char)">
            <summary>
            Checks if one of the remaining bytes are a specified character.
            </summary>
            <param name="ch">Character to find.</param>
            <returns>
            	<c>true</c> if found; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.Read">
            <summary>
            Read a character.
            </summary>
            <returns>
            Character if not EOF; otherwise <c>null</c>.
            </returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadLine">
            <summary>
            Get a text line. 
            </summary>
            <returns></returns>
            <remarks>Will merge multi line headers and rewind of end of line was not found.</remarks> 
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadQuotedString">
            <summary>
            Read quoted string
            </summary>
            <returns>string if current character (in buffer) is a quote; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadToEnd(System.String)">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>
            A string (can be <see cref="F:System.String.Empty"/>).
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadToEnd">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadToEnd(System.Char)">
            <summary>
            Read to end of buffer, or until specified delimiter is found.
            </summary>
            <param name="delimiter">Delimiter to find.</param>
            <returns>
            A string (can be <see cref="F:System.String.Empty"/>).
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadUntil(System.Char)">
            <summary>
            Will read until specified delimiter is found.
            </summary>
            <param name="delimiter">Character to stop at.</param>
            <returns>
            A string if the delimiter was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will trim away spaces and tabs from the end.</remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadUntil(System.String)">
            <summary>
            Read until one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>
            A string if one of the delimiters was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.ReadWord">
            <summary>
            Read until a horizontal white space occurs.
            </summary>
            <returns>A string if a white space was found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.Assign(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Assigns the slice to read from
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="count"> </param>
        </member>
        <member name="M:Griffin.Networking.Buffers.StringBufferSliceReader.Assign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Assign a new buffer
            </summary>
            <param name="buffer">Buffer to process.</param>
            <param name="offset">Where to start process the buffer</param>
            <param name="count">Number if bytes to read</param>
            <exception cref="T:System.ArgumentException">Buffer needs to be a byte array</exception>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.Buffer">
            <summary>
            Gets buffer that we are reading from.
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.EndOfFile">
            <summary>
            Gets if end of buffer have been reached
            </summary>
            <value></value>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.Current">
            <summary>
            Gets current character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.HasMore">
            <summary>
            Gets if more bytes can be processed.
            </summary>
            <value></value>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.Index">
            <summary>
            Gets or sets current position in buffer.
            </summary>
            <remarks>
            THINK before you manually change the position since it can blow up
            the whole parsing in your face.
            </remarks>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.Length">
            <summary>
            Gets total length of buffer.
            </summary>
            <value></value>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.Peek">
            <summary>
            Gets next character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:Griffin.Networking.Buffers.StringBufferSliceReader.RemainingLength">
            <summary>
            Gets number of bytes left.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.BufferSliceStack">
            <summary>
            A stack of buffer slices
            </summary>
            <remarks>Allocates a large buffer which then will be sliced into the number of specified pieces.</remarks>
            <seealso cref="T:Griffin.Networking.Buffers.PooledBufferSlice"/>
        </member>
        <member name="T:Griffin.Networking.Buffers.IBufferSliceStack">
            <summary>
            A stack of buffer slices (i.e. a pool)
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.IBufferSliceStack.Push(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Return a buffer slice
            </summary>
            <param name="slice">Slice</param>
            <remarks>The slice MUST have come from this pool.</remarks>
        </member>
        <member name="M:Griffin.Networking.Buffers.IBufferSliceStack.Pop">
            <summary>
            Pop a slice.
            </summary>
            <returns>Slice given out</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferSliceStack.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.BufferSliceStack"/> class.
            </summary>
            <param name="numberOfBuffers">The number of buffers thar we should support.</param>
            <param name="bufferSize">Number of bytes for one slice.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferSliceStack.Pop">
            <summary>
            Pop a slice from the stack
            </summary>
            <returns>A popped slice</returns>
            <exception cref="T:System.InvalidOperationException">No more slices are available (dont forget to return them by disposing the buffers)</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferSliceStack.Griffin#Networking#Buffers#IBufferSliceStack#Push(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Gives back a slice.
            </summary>
            <param name="slice">The slice.</param>
            <exception cref="T:System.InvalidOperationException">We did not give you away, hence we can't take you. Find your real stack.</exception>
        </member>
        <member name="T:Griffin.Networking.Buffers.BufferWriter">
            <summary>
            Can write information into a slice.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.IBufferWriter">
            <summary>
            Write information into a buffer
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.IBufferWrapper">
            <summary>
            We wrap a buffer and is therefore giving out information about it.
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.IBufferWrapper.Position">
            <summary>
            Gets or sets current position in the buffer
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.IBufferWrapper.Count">
            <summary>
            Gets number of bytes currently written into the buffer
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.IBufferWrapper.Capacity">
            <summary>
            Gets the capactiy of the buffer
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.IBufferWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write something to us from the specified buffer.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentNullException">buffer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset;count;</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.IBufferWriter.Copy(System.IO.Stream)">
            <summary>
            Copy everything from the specified stream into this writer.
            </summary>
            <param name="stream">Stream to copy information from.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.BufferWriter"/> class.
            </summary>
            <remarks>You must use <c>Assign()</c> before you can start using the writer (or by assigning a buffer using the other constructor)</remarks>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferWriter.#ctor(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.BufferWriter"/> class.
            </summary>
            <param name="slice">The slice.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write something to us from the specified buffer.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentNullException">buffer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset;count;</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferWriter.Copy(System.IO.Stream)">
            <summary>
            Copy everything from the specified stream into this writer.
            </summary>
            <param name="stream">Stream to copy information from.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferWriter.Forward(System.Int32)">
            <summary>
            Move position forward in the buffer
            </summary>
            <param name="bytesToMove">Number of bytes to move forward</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferWriter.Assign(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Assign a new slice to this writer
            </summary>
            <param name="slice">Slice to assign</param>
            <remarks>You must have called <see cref="M:Griffin.Networking.Buffers.BufferWriter.Reset"/> first to release last buffer.</remarks>
        </member>
        <member name="M:Griffin.Networking.Buffers.BufferWriter.Reset">
            <summary>
            Dipose last buffer and reset indexes.
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.BufferWriter.Buffer">
            <summary>
            Gets buffer that we are working with
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.BufferWriter.Position">
            <summary>
            Gets current position in the buffer
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.BufferWriter.Count">
            <summary>
            Gets number of bytes written to the buffer
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.BufferWriter.Capacity">
            <summary>
            Gets our buffer capacity
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.CircularStream">
            <summary>
            Not yet completed.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.IPeekable">
            <summary>
            Can peek at the next byte without moving forward.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.IPeekable.Peek">
            <summary>
            Peek at the next byte in the sequence.
            </summary>
            <returns>Char if not EOF; otherwise <see cref="F:System.Char.MinValue"/></returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.CircularStream"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.CircularStream"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="capacity">The capacity.</param>
            <param name="writtenCount">The written count.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.Peek">
            <summary>
            Peek at the next byte in the sequence.
            </summary>
            <returns>
            Char if not EOF; otherwise <see cref="F:System.Char.MinValue"/>
            </returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.Clear(System.Int32,System.Int32)">
            <summary>
            Clears the specified offset.
            </summary>
            <param name="offset">The offset.</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. 
                            </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <returns>
            The new position within the current stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter. 
                            </param><param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position. 
                            </param><exception cref="T:System.IO.IOException">An I/O error occurs. 
                            </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. 
                            </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. 
                            </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. 
                            </param><exception cref="T:System.IO.IOException">An I/O error occurs. 
                            </exception><exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. 
                            </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. 
                            </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source. 
                            </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream. 
                            </param><param name="count">The maximum number of bytes to be read from the current stream. 
                            </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length. 
                            </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. 
                            </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. 
                            </exception><exception cref="T:System.IO.IOException">An I/O error occurs. 
                            </exception><exception cref="T:System.NotSupportedException">The stream does not support reading. 
                            </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. 
                            </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Buffers.CircularStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream. 
                            </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream. 
                            </param><param name="count">The number of bytes to be written to the current stream. 
                            </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is greater than the buffer length. 
                            </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. 
                            </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. 
                            </exception><exception cref="T:System.IO.IOException">An I/O error occurs. 
                            </exception><exception cref="T:System.NotSupportedException">The stream does not support writing. 
                            </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. 
                            </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.CircularStream.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <returns>
            true if the stream supports reading; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.CircularStream.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <returns>
            true if the stream supports seeking; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.CircularStream.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <returns>
            true if the stream supports writing; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.CircularStream.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. 
                            </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. 
                            </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.CircularStream.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. 
                            </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking. 
                            </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. 
                            </exception><filterpriority>1</filterpriority>
        </member>
        <member name="T:Griffin.Networking.Buffers.IBufferReader">
            <summary>
            Read from a buffer into a stream
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.IBufferReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write our information into another buffer
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentNullException">buffer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset;count</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.IBufferReader.Read">
            <summary>
            Read one byte
            </summary>
            <returns>Byte if read; -1 if end of stream.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.IBufferReader.CopyTo(System.IO.Stream,System.Int32)">
            <summary>
            Write our contents to another stream
            </summary>
            <param name="other">Stream to write to</param>
            <param name="count">Number of bytes to write</param>
            <returns>Bytes written</returns>
        </member>
        <member name="P:Griffin.Networking.Buffers.IBufferReader.RemainingLength">
            <summary>
            Gets number of bytes left from the current postion to <see cref="P:Griffin.Networking.Buffers.IBufferWrapper.Count"/>.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.IBufferStream">
            <summary>
            We are a stream which is wrapping a buffer (or a slice)
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.NamespaceDoc">
            <summary>
            Contains buffer handling
            </summary>
            <remarks>Do note that it's recommended that you pool buffers (i.e.) reuse them. You can use the <see cref="T:Griffin.Networking.Buffers.BufferSliceStack"/> for that.
            
            <para>All buffers that are reusable should implement <c>IDisposable</c>. Return the buffer to the pool on disposal. You therefore
            also have to check each buffer if it's disposable when you are done with it (and dispose it if it is).</para>
            </remarks>
        </member>
        <member name="T:Griffin.Networking.Buffers.PeekableMemoryStream">
            <summary>
            A memory stream that supports <see cref="T:Griffin.Networking.Buffers.IPeekable"/>.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.PeekableMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.PeekableMemoryStream"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.PeekableMemoryStream.Peek">
            <summary>
            Peek at the next byte in the sequence.
            </summary>
            <returns>Char if not EOF; otherwise <see cref="F:System.Char.MinValue"/></returns>
        </member>
        <member name="T:Griffin.Networking.Buffers.PooledBufferSlice">
            <summary>
            We are a slice which should get returned to a pool when done
            </summary>
            <remarks>It's important that you check if a buffer implement <code>IDisposable</code> since you then have
            to invoke <c>Dispose()</c> when done to return the buffer to the pool.
            </remarks>
            <seealso cref="T:Griffin.Networking.Buffers.BufferSliceStack"/>
        </member>
        <member name="M:Griffin.Networking.Buffers.PooledBufferSlice.#ctor(Griffin.Networking.Buffers.IBufferSliceStack,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.PooledBufferSlice"/> class.
            </summary>
            <param name="bufferSliceStack">The buffer slice stack.</param>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.PooledBufferSlice.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Buffers.PooledBufferSlice.IsMyStack(Griffin.Networking.Buffers.IBufferSliceStack)">
            <summary>
            Checks if the supplied stack is the one that we came from
            </summary>
            <param name="stack">Stack to check</param>
            <returns><c>>true</c> if our; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.PooledBufferSlice.Reset">
            <summary>
            Reset buffer (i.e. go back to initial size and offset)
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.PooledBufferSlice.Buffer">
            <summary>
            Gets buffer that we are working with
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.PooledBufferSlice.Offset">
            <summary>
            Gets current offset
            </summary>
        </member>
        <member name="P:Griffin.Networking.Buffers.PooledBufferSlice.Count">
            <summary>
            Gets number of bytes in the buffer
            </summary>
        </member>
        <member name="T:Griffin.Networking.Buffers.SliceStream">
            <summary>
            A stream operating on a buffer slice.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.#ctor(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.SliceStream"/> class.
            </summary>
            <param name="slice">The slice to use.</param>
            <exception cref="T:System.ArgumentNullException">slice</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.#ctor(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Buffers.SliceStream"/> class.
            </summary>
            <param name="slice">The slice.</param>
            <param name="length">Number of bytes which have already been written to the buffer.</param>
            <exception cref="T:System.ArgumentNullException">slice</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">length;Must be less or equal to slice length which is  + slice.Count</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentNullException">buffer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset;count</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.Read">
            <summary>
            Read one byte
            </summary>
            <returns>Byte if read; -1 if end of stream.</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.CopyTo(System.IO.Stream,System.Int32)">
            <summary>
            Write our contents to another stream
            </summary>
            <param name="other">Stream to write to</param>
            <param name="count">Number of bytes to write</param>
            <returns>Bytes written</returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentNullException">buffer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset;count;</exception>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.Copy(System.IO.Stream)">
            <summary>
            Copy everything from the specified stream into this writer.
            </summary>
            <param name="stream">Stream to copy information from.</param>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.Peek">
            <summary>
            Peek at the next byte in the sequence.
            </summary>
            <returns>Char if not EOF; otherwise <see cref="F:System.Char.MinValue"/></returns>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <returns>
            The new position within the current stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter. </param><param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Buffers.SliceStream.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.SliceStream.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <returns>
            true if the stream supports reading; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.SliceStream.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <returns>
            true if the stream supports seeking; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.SliceStream.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <returns>
            true if the stream supports writing; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.SliceStream.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.SliceStream.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:Griffin.Networking.Buffers.SliceStream.RemainingLength">
            <summary>
            Gets number of bytes left from the current postion to <see cref="P:Griffin.Networking.Buffers.IBufferWrapper.Count"/>.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Clients.BinaryClient">
            <summary>
            Represents a client connection which is only transfering byte[] buffers.
            </summary>
            <remarks>Gives you fill control of everything sent, including the buffers used. Typically used to gain
            speed, sending large objects or streaming.</remarks>
        </member>
        <member name="T:Griffin.Networking.Clients.ClientBase">
            <summary>
            Base class for clients.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Clients.ClientBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Messaging.MessagingClient"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Clients.ClientBase.HandleDisconnect(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            The remote end point have disconnected (or network failure)
            </summary>
            <param name="socketAsyncEventArgs"></param>
        </member>
        <member name="M:Griffin.Networking.Clients.ClientBase.OnReceived(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            We've received something from the other end
            </summary>
            <param name="buffer">Buffer containing the received bytes</param>
            <param name="bytesRead">Amount of bytes that we received</param>
            <remarks>You have to handle all bytes, anything left will be discarded.</remarks>
        </member>
        <member name="M:Griffin.Networking.Clients.ClientBase.Send(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Send something to the remote end point
            </summary>
            <param name="slice">Slice to send. It's up to you to make sure that it's returned to the pool (if pooled)</param>
            <param name="count">Number of bytes in the buffer</param>
        </member>
        <member name="M:Griffin.Networking.Clients.ClientBase.Send(System.IO.Stream)">
            <summary>
            Send a stream
            </summary>
            <param name="stream">Stream to send</param>
            <remarks>The stream will be owned by the framework, i.e. disposed when sent.</remarks>
        </member>
        <member name="M:Griffin.Networking.Clients.ClientBase.Connect(System.Net.IPEndPoint)">
            <summary>
            Connect to an end point
            </summary>
            <param name="remoteEndPoint">end point</param>
        </member>
        <member name="M:Griffin.Networking.Clients.ClientBase.Close">
            <summary>
            Close connection and clean up
            </summary>
        </member>
        <member name="E:Griffin.Networking.Clients.ClientBase.Disconnected">
            <summary>
            Other side disconnected (or network failure)
            </summary>
        </member>
        <member name="M:Griffin.Networking.Clients.BinaryClient.OnReceived(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            We've received something from the other end
            </summary>
            <param name="buffer">Buffer containing the received bytes</param>
            <param name="bytesRead">Amount of bytes that we received</param>
            <remarks>
            You have to handle all bytes, anything left will be discarded.
            </remarks>
        </member>
        <member name="E:Griffin.Networking.Clients.BinaryClient.Received">
            <summary>
            We received something from the server
            </summary>
        </member>
        <member name="T:Griffin.Networking.ISocketWriterJob">
            <summary>
            We would like to be able to send both <c>byte[]</c> and <c>Stream</c> objects. And to be able to do that
            we need to be able to manage the writes.
            </summary>
            <remarks>Make sure that you dispose the stream or the buffer when dispose is being called by the framework.</remarks>
        </member>
        <member name="M:Griffin.Networking.ISocketWriterJob.Write(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Write stuff to our args.
            </summary>
            <param name="args">Args used when sending bytes to the socket</param>
            <remarks>The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken"/> contains a <c>IBufferSlice</c> which can be used
            for write operations. You are free to use it, but do NOT change the <c>UserToken</c>.</remarks>
        </member>
        <member name="M:Griffin.Networking.ISocketWriterJob.WriteCompleted(System.Int32)">
            <summary>
            The async write has been completed
            </summary>
            <param name="bytes">Number of bytes that was sent</param>
            <returns><c>true</c> if everything was sent; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Griffin.Networking.Messaging.MessagingClient">
            <summary>
            A client connection (i.e. a client which connects to a server)
            </summary>
            <remarks>A client that can connect to the <see cref="T:Griffin.Networking.Messaging.MessagingServer"/>. This client needs a messaging
            formatter. You could for instance
            download the <c>griffin.networking.basic</c> nuget package to get started directly.</remarks>
            <seealso cref="T:Griffin.Networking.Messaging.IMessageFormatterFactory"/>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingClient.#ctor(Griffin.Networking.Messaging.IMessageFormatterFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Messaging.MessagingClient"/> class.
            </summary>
            <param name="formatterFactory">The formatter factory.</param>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingClient.OnReceived(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            We've received something from the other end
            </summary>
            <param name="buffer">Buffer containing the received bytes</param>
            <param name="bytesRead">Amount of bytes that we received</param>
            <remarks>You have to handle all bytes, anything left will be discarded.</remarks>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingClient.Send(System.Object)">
            <summary>
            Send a message
            </summary>
            <param name="message">Message to send</param>
            <remarks>Message will be serialized using the <see cref="T:Griffin.Networking.Messaging.IMessageFormatterFactory"/> that you've specified in the constructor.</remarks>
        </member>
        <member name="E:Griffin.Networking.Messaging.MessagingClient.Received">
            <summary>
            Received a new message
            </summary>
        </member>
        <member name="T:Griffin.Networking.Clients.NamespaceDoc">
            <summary>
            This namespace contains classes which are used at the client side.
            </summary>
            <example>
            <code>
            class Program
            {
            	static void Main(string[] args)
            	{
            		//Setup, we are using the built in formatter which can transport any POCO (using XML with a binary header)
            		var client = new MessagingClient(new BasicMessageFormatterFactory());
            		client.Received += OnMessage;
            
            		//Connect to server
            		client.Connect(new IPEndPoint(IPAddress.Loopback, 8844));
            
            		// Send a message
            		client.Send(new InvokeME(){Hello = "World"});
            
            		Console.ReadLine();
            
            	}
            
            	// Receive a message from the server
            	private static void OnMessage(object sender, ReceivedMessageEventArgs e)
            	{
            		var msg = (Pong) e.Message;
            		Console.WriteLine("Got ponged from server. The pong was sent at " + msg.PongedAt);
            	}
            }
            </code>
            </example>
        </member>
        <member name="T:Griffin.Networking.Clients.ReceivedBufferEventArgs">
            <summary>
            We've received something from the client.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Clients.ReceivedBufferEventArgs.#ctor(Griffin.Networking.Buffers.IBufferReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Clients.ReceivedBufferEventArgs"/> class.
            </summary>
            <param name="bufferReader">The buffer reader.</param>
        </member>
        <member name="P:Griffin.Networking.Clients.ReceivedBufferEventArgs.BufferReader">
            <summary>
            Gets reader which we can get bytes from
            </summary>
        </member>
        <member name="T:Griffin.Networking.Messaging.MessagingService">
            <summary>
            Service which can send and receive messages.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Servers.IServerService">
            <summary>
            Represents that class that will handle a connection from the client
            </summary>
            <remarks>The server will invoke dispose when the client has disconnected.</remarks>
        </member>
        <member name="M:Griffin.Networking.Servers.IServerService.Assign(Griffin.Networking.Servers.IServerClientContext)">
            <summary>
            Assign the context which can be used to communicate with the client
            </summary>
            <param name="context">Context</param>
        </member>
        <member name="M:Griffin.Networking.Servers.IServerService.HandleReceive(System.Object)">
            <summary>
            A new message have been received from the remote end.
            </summary>
            <param name="message">Message type depends on the type of client/server you are using. See the remarks.</param>
            <remarks><para>A clean <see cref="T:Griffin.Networking.Servers.Server"/> will give you a <see cref="T:Griffin.Networking.Buffers.SliceStream"/> here.</para><para>Other server implementations might give you something else.</para></remarks>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingService.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingService.Griffin#Networking#Servers#IServerService#Assign(Griffin.Networking.Servers.IServerClientContext)">
            <summary>
            Assign the context which can be used to communicate with the client
            </summary>
            <param name="context">Context</param>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingService.HandleReceive(System.Object)">
            <summary>
            A new message have been received from the remote end.
            </summary>
            <param name="message"></param>
            <remarks>We'll deserialize messages for you. What you receive here depends on the used <see cref="T:Griffin.Networking.Messaging.IMessageFormatterFactory"/>.</remarks>
        </member>
        <member name="P:Griffin.Networking.Messaging.MessagingService.Context">
            <summary>
            Gets context used to send stuff.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Messaging.ReceivedMessageEventArgs">
            <summary>
            We have received a new message in the <see cref="T:Griffin.Networking.Messaging.MessagingClient"/>.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Messaging.ReceivedMessageEventArgs.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Messaging.ReceivedMessageEventArgs"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="P:Griffin.Networking.Messaging.ReceivedMessageEventArgs.Message">
            <summary>
            Gets message that we've received
            </summary>
            <remarks>The type of message depends on what you've sent from the other end and on the <see cref="T:Griffin.Networking.Messaging.IMessageFormatterFactory"/> that you are using.</remarks>
        </member>
        <member name="T:Griffin.Networking.DisconnectEventArgs">
            <summary>
            We've been disconnected
            </summary>
        </member>
        <member name="M:Griffin.Networking.DisconnectEventArgs.#ctor(System.Net.Sockets.SocketError)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.DisconnectEventArgs"/> class.
            </summary>
            <param name="socketError">The socket error that resulted in the disconnection.</param>
        </member>
        <member name="P:Griffin.Networking.DisconnectEventArgs.SocketError">
            <summary>
            Gets socket error that resulted in the disconnection.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Messaging.MessagingServer">
            <summary>
            Sends/Receives messages (POCOs) from one/many clients.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Servers.Server">
            <summary>
            Uses a <see cref="T:Griffin.Networking.Servers.IServiceFactory"/> to create the connection handlers.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Servers.ServerBase">
            <summary>
            Contains most of the logic, but do not dictate how you should handle clients.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.#ctor(Griffin.Networking.Servers.ServerConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Servers.Server"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.CreateClientContext(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Create a new client context
            </summary>
            <param name="readBuffer">The read buffer to use</param>
            <returns>Created context</returns>
            <remarks>The contexts are created at startup and then reused during the server lifetime. A context
            is assigned to a socket each time we've accepted one using the listener.</remarks>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.OnClientDisconnectedInternal(System.Object,System.EventArgs)">
            <summary>
            A client has disconnected
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.OnClientDisconnected(Griffin.Networking.Servers.ServerClientContext)">
            <summary>
            A client has disconnected from the server (either network failure or by the remote end point)
            </summary>
            <param name="context">Disconnected client</param>
            <remarks>Calls to <see cref="M:Griffin.Networking.Servers.ServerClientContext.Close"/> will also trigger this method, but with <see cref="F:System.Net.Sockets.SocketError.Success"/>. 
            <para>The method is typically used to clean up your own implementation. The context, socket ETC have already been cleaned up.</para></remarks>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.Start(System.Net.IPEndPoint)">
            <summary>
            Start server and begin accepting end points.
            </summary>
            <param name="localEndPoint">End point that the server should listen on.</param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.CreateClient(System.Net.EndPoint)">
            <summary>
            Create a new object which will handle all communication to/from a specific client.
            </summary>
            <param name="remoteEndPoint">Remote end point</param>
            <returns>Created client</returns>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.OnClientConnected(Griffin.Networking.Servers.ServerClientContext)">
            <summary>
            A new client have connected
            </summary>
            <param name="context">Client context</param>
            <remarks>Invoked when a client has been validated and successfully been added.</remarks>
            <seealso cref="M:Griffin.Networking.Servers.ServerBase.ValidateClient(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.ValidateClient(System.Net.Sockets.Socket)">
            <summary>
            A new client have connected
            </summary>
            <param name="acceptedSocket">Socket for the client</param>
            <returns><c>true</c> if the client can be accepted; <c>false</c> to disconnect the client.</returns>
            <remarks>Use this method to filter out any unwanted clients. Feel free to use it for any handshake etc.</remarks>
            <seealso cref="M:Griffin.Networking.Servers.ServerBase.OnClientConnected(Griffin.Networking.Servers.ServerClientContext)"/>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerBase.Stop">
            <summary>
            Stop accepting new connections
            </summary>
            <remarks>Any existing connections will continue to run until they disconnect.</remarks>
        </member>
        <member name="M:Griffin.Networking.Servers.Server.#ctor(Griffin.Networking.Servers.IServiceFactory,Griffin.Networking.Servers.ServerConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Servers.Server"/> class.
            </summary>
            <param name="clientFactory">The client factory.</param>
            <param name="configuration">The configuration.</param>
            <exception cref="T:System.ArgumentNullException">clientFactory</exception>
        </member>
        <member name="M:Griffin.Networking.Servers.Server.CreateClient(System.Net.EndPoint)">
            <summary>
            Create a new object which will handle all communication to/from a specific client.
            </summary>
            <param name="remoteEndPoint">Remote end point</param>
            <returns>Created client</returns>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingServer.#ctor(Griffin.Networking.Servers.IServiceFactory,Griffin.Networking.Messaging.MessagingServerConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Messaging.MessagingServer"/> class.
            </summary>
            <param name="clientFactory">Used to create the class that you use to handle all client communication.</param>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingServer.CreateClientContext(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Creates <see cref="T:Griffin.Networking.Messaging.MessagingClientContext"/>
            </summary>
            <param name="readBuffer">Read buffer</param>
            <returns>Created client</returns>
        </member>
        <member name="T:Griffin.Networking.Pipelines.IDownstreamHandler">
            <summary>
            A handler used to process everything sent from the client down to the channel
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.IPipelineHandler">
            <summary>
            Purpose is to be able to register the same handler for both upstream and downstream in the bluprint
            </summary>
            <remarks>
            You should not derive this class directly.
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IDownstreamHandler.HandleDownstream(Griffin.Networking.Pipelines.IPipelineHandlerContext,Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Process message
            </summary>
            <param name="context"></param>
            <param name="message"></param>
            <remarks>
            Should always call either <see cref="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendDownstream(Griffin.Networking.Pipelines.IPipelineMessage)"/> or <see cref="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendUpstream(Griffin.Networking.Pipelines.IPipelineMessage)"/>
            unless the handler really wants to stop the processing.
            </remarks>
        </member>
        <member name="T:Griffin.Networking.Pipelines.IPipeline">
            <summary>
            Pipeline used to send information to/from a channel
            </summary>
            <remarks>
            <para>
            All messages that a <see cref="T:Griffin.Networking.Pipelines.IPipelineHandler"/> can't process should be sent to the next handler
            using the supplied <see cref="T:Griffin.Networking.Pipelines.Messages.PipelineFailure"/>.
            </para>
            <para>
            Any failures in the pipeline should be be caught by the handler itself and sent upstream using the <see cref="T:Griffin.Networking.Pipelines.IPipelineHandlerContext"/> message. It gives the
            client a chance to decide which action to be taken.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IPipeline.SendUpstream(Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Send something from the channel to all handlers.
            </summary>
            <param name="message">Message to send to the client</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IPipeline.SetChannel(Griffin.Networking.Pipelines.IDownstreamHandler)">
            <summary>
            Set down stream end point
            </summary>
            <param name="handler"> </param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IPipeline.SendDownstream(Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Send a message from the client and downwards.
            </summary>
            <param name="message">Message to send to the channel</param>
        </member>
        <member name="T:Griffin.Networking.Pipelines.IPipelineFactory">
            <summary>
            Used to produce the pipeline that is used by a connection
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IPipelineFactory.Build">
            <summary>
            Create a pipeline for a channel
            </summary>
            <returns>Created pipeline</returns>
        </member>
        <member name="T:Griffin.Networking.Pipelines.IPipelineHandlerContext">
            <summary>
            Context assigned to each channel to be able to continue down the chain or to change direction in the pipe
            </summary>
            <remarks>
            It depends of the type of channel how the processing is done. A <see cref="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendDownstream(Griffin.Networking.Pipelines.IPipelineMessage)"/> will let the
            processing continue down the pipe when calling <see cref="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendUpstream(Griffin.Networking.Pipelines.IPipelineMessage)"/> while it moves the message to the beginning
            of the pipe if calling <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> (to let all up stream handlers have a chance to process the message).
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendUpstream(Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Send message up towards the client
            </summary>
            <param name="message">Message to process</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendDownstream(Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Sned the message down towards the channel
            </summary>
            <param name="message">Message to process</param>
        </member>
        <member name="T:Griffin.Networking.Pipelines.IPipelineMessage">
            <summary>
            A message being sent either downstream or upstream in a pipeline
            </summary>
        </member>
        <member name="T:Griffin.Networking.IServiceLocator">
            <summary>
            Used to build all <see cref="T:Griffin.Networking.Pipelines.IPipelineHandler"/> classes.
            </summary>
            <remarks>
            <para>Important! It's up to your container to resolve the same instance of an class if it implements both <see cref="T:Griffin.Networking.Pipelines.IUpstreamHandler"/> and <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> (and
            you need to use the same fields in both cases).
            </para>
            
            </remarks>
        </member>
        <member name="M:Griffin.Networking.IServiceLocator.Resolve(System.Type)">
            <summary>
            Resolve a service
            </summary>
            <param name="type">Type of service to locate.</param>
            <returns>The registered service</returns>
            <exception cref="T:System.InvalidOperationException">Failed to find service.</exception>
        </member>
        <member name="T:Griffin.Networking.Pipelines.IUpstreamHandler">
            <summary>
            Used to process messages that are sent from the channel up towards the client
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.IUpstreamHandler.HandleUpstream(Griffin.Networking.Pipelines.IPipelineHandlerContext,Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Handle an message
            </summary>
            <param name="context">Context unique for this handler instance</param>
            <param name="message">Message to process</param>
            <remarks>
            All messages that can't be handled MUST be send up the chain using <see cref="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendUpstream(Griffin.Networking.Pipelines.IPipelineMessage)"/>.
            </remarks>
        </member>
        <member name="T:Griffin.Networking.Logging.BaseLogger">
            <summary>
            Base class for loggers.
            </summary>
            <remarks>All you have to do is to override <see cref="M:Griffin.Networking.Logging.BaseLogger.Write(Griffin.Networking.Logging.LogLevel,System.String,System.Exception)"/>.</remarks>
        </member>
        <member name="T:Griffin.Networking.Logging.ILogger">
            <summary>
            Logging interface
            </summary>
            <remarks>You typically just want to log the warnings and the errors from the framework since your logs
            will probably be filled very quickly otherwise.</remarks>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Trace(System.String)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Debug(System.String)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Warning(System.String)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Error(System.String)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Logging.BaseLogger"/> class.
            </summary>
            <param name="loggedType">Type being logged.</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Trace(System.String)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Debug(System.String)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Debug(System.String,System.Exception)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Warning(System.String)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Error(System.String)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.Write(Griffin.Networking.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Writes the specified log level.
            </summary>
            <param name="logLevel">Used level.</param>
            <param name="msg">Message.</param>
            <param name="exception">The exception (or null).</param>
        </member>
        <member name="M:Griffin.Networking.Logging.BaseLogger.BuildExceptionDetails(System.Exception,System.Int32)">
            <summary>
            Formats exception details (including all inner exceptions)
            </summary>
            <param name="exception">Thrown exception.</param>
            <param name="spaces">Number of spaces to prefix each line with.</param>
            <returns>Formatted exception information</returns>
            <remarks>Increases the number of spaces for each inner exception so it's easy to see all information</remarks>
        </member>
        <member name="P:Griffin.Networking.Logging.BaseLogger.SkipFrameCount">
            <summary>
            Gets number of frames to skip when using stack trace
            </summary>
        </member>
        <member name="P:Griffin.Networking.Logging.BaseLogger.LoggedType">
            <summary>
            Gets the type for the class which logs using this class
            </summary>
        </member>
        <member name="T:Griffin.Networking.Logging.ConsoleLogger">
            <summary>
            Log everything to the console
            </summary>
            <remarks>Prints one stack frame using colored output.</remarks>
        </member>
        <member name="M:Griffin.Networking.Logging.ConsoleLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Logging.ConsoleLogger"/> class.
            </summary>
            <param name="loggedType">Type being logged.</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ConsoleLogger.Write(Griffin.Networking.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Writes the specified log level.
            </summary>
            <param name="logLevel">Used level.</param>
            <param name="msg">Message.</param>
            <param name="exception">The exception (or null).</param>
        </member>
        <member name="M:Griffin.Networking.Logging.ConsoleLogger.GetColor(Griffin.Networking.Logging.LogLevel)">
            <summary>
            Get a color for a specific log level
            </summary>
            <param name="logLevel">Level to get color for</param>
            <returns>Level color</returns>
        </member>
        <member name="P:Griffin.Networking.Logging.ConsoleLogger.SkipFrameCount">
            <summary>
            Gets number of frames to skip when using stack trace
            </summary>
        </member>
        <member name="T:Griffin.Networking.Logging.FilteredLogger">
            <summary>
            Logger that filters on level
            </summary>
        </member>
        <member name="M:Griffin.Networking.Logging.FilteredLogger.#ctor(System.Type,Griffin.Networking.Logging.BaseLogger)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Logging.FilteredLogger"/> class.
            </summary>
            <param name="type">Tyep that logs.</param>
            <param name="innerLogger">The inner logger (invoked if the filter requirements are fulfilled).</param>
        </member>
        <member name="M:Griffin.Networking.Logging.FilteredLogger.#ctor(Griffin.Networking.Logging.LogLevel,System.Type,Griffin.Networking.Logging.BaseLogger)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Logging.FilteredLogger"/> class.
            </summary>
            <param name="minLevel">The minimum level to log.</param>
            <param name="loggedType">Type being logged.</param>
            <param name="innerLogger">The inner logger (invoked if the filter requirements are fulfilled).</param>
        </member>
        <member name="M:Griffin.Networking.Logging.FilteredLogger.Write(Griffin.Networking.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Logs an entry to the source
            </summary>
            <param name="logLevel">Used level.</param>
            <param name="msg">Message.</param>
            <param name="exception">The exception (or null).</param>
        </member>
        <member name="P:Griffin.Networking.Logging.FilteredLogger.SkipFrameCount">
            <summary>
            Gets number of frames to skip when using stack trace
            </summary>
        </member>
        <member name="T:Griffin.Networking.Logging.LogLevel">
            <summary>
            Log levels
            </summary>
        </member>
        <member name="F:Griffin.Networking.Logging.LogLevel.Trace">
            <summary>
            Very detailed logs used during diagnostics
            </summary>
        </member>
        <member name="F:Griffin.Networking.Logging.LogLevel.Debug">
            <summary>
            Diagnostics
            </summary>
        </member>
        <member name="F:Griffin.Networking.Logging.LogLevel.Info">
            <summary>
            Events and similar
            </summary>
        </member>
        <member name="F:Griffin.Networking.Logging.LogLevel.Warning">
            <summary>
            Something failed, but processing can continue
            </summary>
        </member>
        <member name="F:Griffin.Networking.Logging.LogLevel.Error">
            <summary>
            Something failed, expected execution path can not succeed.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Logging.LogManager">
            <summary>
            Logging facade
            </summary>
            <remarks>Implement an adapter for your own logging framework and assign it using <see cref="M:Griffin.Networking.Logging.LogManager.Assign(Griffin.Networking.Logging.LogManager)"/></remarks>
        </member>
        <member name="M:Griffin.Networking.Logging.LogManager.GetLogger``1">
            <summary>
            Get a logger
            </summary>
            <typeparam name="T">Type requesting a logger</typeparam>
            <returns>A logger</returns>
        </member>
        <member name="M:Griffin.Networking.Logging.LogManager.GetLogger(System.Type)">
            <summary>
            Get a logger
            </summary>
            <param name="loggingType">Type that will log messages</param>
            <returns>A logger</returns>
        </member>
        <member name="M:Griffin.Networking.Logging.LogManager.GetLoggerInternal(System.Type)">
            <summary>
            Get a logger for a type
            </summary>
            <param name="loggingType">Type that want's a logger</param>
            <returns>Default implementation returns a <see cref="T:Griffin.Networking.Logging.NullLogger"/></returns>
        </member>
        <member name="M:Griffin.Networking.Logging.LogManager.Assign(Griffin.Networking.Logging.LogManager)">
            <summary>
            Assign a logging adapter.
            </summary>
            <param name="logManager">Manager to use</param>
        </member>
        <member name="P:Griffin.Networking.Logging.LogManager.Current">
            <summary>
            Get the current adapter
            </summary>
        </member>
        <member name="T:Griffin.Networking.Logging.NamespaceDoc">
            <summary>
            Contains a logging abstraction layer allowing you to use your favorite logging framework.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Logging.NullLogger">
            <summary>
            Throws away all logs
            </summary>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Trace(System.String)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Debug(System.String)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Debug(System.String,System.Exception)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Warning(System.String)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Error(System.String)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
        </member>
        <member name="M:Griffin.Networking.Logging.NullLogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="T:Griffin.Networking.Logging.SimpleFilteredLogManager`1">
            <summary>
            Logs all entries which has a minimum log level
            </summary>
            <typeparam name="T">Type of inner logger</typeparam>
        </member>
        <member name="M:Griffin.Networking.Logging.SimpleFilteredLogManager`1.#ctor(Griffin.Networking.Logging.LogLevel)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Logging.SimpleFilteredLogManager`1"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Logging.SimpleFilteredLogManager`1.GetLoggerInternal(System.Type)">
            <summary>
            Get a logger for a type
            </summary>
            <param name="loggingType">Type that want's a logger</param>
            <returns>
            Logger
            </returns>
        </member>
        <member name="T:Griffin.Networking.Logging.SimpleLogManager`1">
            <summary>
            Log manager which uses one of the base loggers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Griffin.Networking.Logging.SimpleLogManager`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Logging.SimpleLogManager`1"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Logging.SimpleLogManager`1.GetLoggerInternal(System.Type)">
            <summary>
            Get a logger for a type
            </summary>
            <param name="loggingType">Type that want's a logger</param>
            <returns>
            Logger
            </returns>
        </member>
        <member name="T:Griffin.Networking.Logging.SystemDebugLogger">
            <summary>
            Logs to the debug window in Visual Studio
            </summary>
        </member>
        <member name="M:Griffin.Networking.Logging.SystemDebugLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Logging.SystemDebugLogger"/> class.
            </summary>
            <param name="loggedType">Type being logged.</param>
        </member>
        <member name="M:Griffin.Networking.Logging.SystemDebugLogger.Write(Griffin.Networking.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Writes the specified log level.
            </summary>
            <param name="logLevel">Used level.</param>
            <param name="msg">Message.</param>
            <param name="exception">The exception (or null).</param>
        </member>
        <member name="P:Griffin.Networking.Logging.SystemDebugLogger.SkipFrameCount">
            <summary>
            Gets number of frames to skip when using stack trace
            </summary>
        </member>
        <member name="T:Griffin.Networking.Messaging.IMessageBuilder">
            <summary>
            Used to build a message from buffers
            </summary>
        </member>
        <member name="M:Griffin.Networking.Messaging.IMessageBuilder.Append(Griffin.Networking.Buffers.IBufferReader)">
            <summary>
            Append more bytes to your message building
            </summary>
            <param name="reader">Contains bytes which was received from the other end</param>
            <returns><c>true</c> if a complete message has been built; otherwise <c>false</c>.</returns>
            <remarks>You must handle/read everything which is available in the buffer</remarks>
        </member>
        <member name="M:Griffin.Networking.Messaging.IMessageBuilder.TryDequeue(System.Object@)">
            <summary>
            Try to dequeue a message
            </summary>
            <param name="message">Message that the builder has built.</param>
            <returns><c>true</c> if a message was available; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Griffin.Networking.Messaging.IMessageFormatterFactory">
            <summary>
            The following factory are used to provide the classes that are used to convert your .NET POCOS to something
            that can be transported over a socket and vice versa.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Messaging.IMessageFormatterFactory.CreateSerializer">
            <summary>
            Create a new serializer (used to convert messages to byte buffers)
            </summary>
            <returns>Created serializer</returns>
        </member>
        <member name="M:Griffin.Networking.Messaging.IMessageFormatterFactory.CreateBuilder">
            <summary>
            Create a message builder (used to compose messages from byte buffers)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Griffin.Networking.Messaging.IMessageSerializer">
            <summary>
            Serializes the message into the writer
            </summary>
        </member>
        <member name="M:Griffin.Networking.Messaging.IMessageSerializer.Serialize(System.Object,Griffin.Networking.Buffers.IBufferWriter)">
            <summary>
            Serialize a message into something that can be transported over the socket.
            </summary>
            <param name="message">Message to serialize</param>
            <param name="writer">Buffer used to store the message</param>
        </member>
        <member name="T:Griffin.Networking.Messaging.NamespaceDoc">
            <summary>
            Server &amp; Client implementation that can transfer messages (POCOs) over the network.
            </summary>
            <remarks>Do note that the actual format of the transfers are not defined in this namespace. You can
            however install the <c>griffin.networking.basic</c> nuget package to get a messaging implementation
            that uses a small binary header (version+length) and JSON to transport all pocos.</remarks>
            <example>
            Server configuration:
            
            
            </example>
            <seealso cref="T:Griffin.Networking.Messaging.MessagingServer"/>
            <seealso cref="T:Griffin.Networking.Pipelines.PipelineServer"/>
            <seealso cref="T:Griffin.Networking.Servers.ServerBase"/>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.ClientConnected">
            <summary>
            A client have connected to our server.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.ClientConnected.#ctor(Griffin.Networking.Servers.IServerService)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.ClientConnected"/> class.
            </summary>
            <param name="client">The client.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.ClientConnected.Client">
            <summary>
            Gets client
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.BindSocket">
            <summary>
            bind socket for a server channel
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.BindSocket.#ctor(System.Net.IPEndPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.BindSocket"/> class.
            </summary>
            <param name="endPoint">The end point.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.BindSocket.EndPoint">
            <summary>
            Gets enpoint to bind
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Close">
            <summary>
            Close a channel
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Closed">
            <summary>
            Channel/pipeline will be closed after this message have been handled.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Connect">
            <summary>
            Connect to a server
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.Connect.#ctor(System.Net.EndPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.Connect"/> class.
            </summary>
            <param name="remoteEndPoint">The remote end point.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.Connect.RemoteEndPoint">
            <summary>
            Gets end point to connect to
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Connected">
            <summary>
            Connected to an end point
            </summary>
            <remarks>
            Can be sent both in server and client channels to indicate that an connection have been established.
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.Connected.#ctor(System.Net.EndPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.Connected"/> class.
            </summary>
            <param name="remoteEndPoint">The remote end point.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.Connected.RemoteEndPoint">
            <summary>
            Gets address of the remote end point
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Disconnect">
            <summary>
            Disconnect from remote end point.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Disconnected">
            <summary>
            A channel have been disconnected by remote peer
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.Disconnected.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.Disconnected"/> class.
            </summary>
            <param name="exception">NULL = graceful disconnect.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.Disconnected.Exception">
            <summary>
            Gets thrown exception (unless we got disconnected gracefully)
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.PipelineFailure">
            <summary>
            One of the handlers failed.
            </summary>
            <remarks>Will be sent when one of the handlers threw an exception that wasn't handled. The channel and pipeline will be cleaned up
            and <see cref="T:Griffin.Networking.Pipelines.Messages.Closed"/> after this message have been handled.</remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.PipelineFailure.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.PipelineFailure"/> class.
            </summary>
            <param name="exception">The exception.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.PipelineFailure.Exception">
            <summary>
            Gets exception that was thrown by a handler in the pipeline
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Received">
            <summary>
            We've received bytes from the remote peer.
            </summary>
            <remarks>The buffer will be compacted by the channel when the message has been handled. It's thefore important that <c>BufferSlice.Position</c> is kept
            on the byte after the last read position.</remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.Received.#ctor(System.Net.EndPoint,Griffin.Networking.Buffers.IBufferReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.Received"/> class.
            </summary>
            <param name="remoteEndPoint">The remote end point.</param>
            <param name="reader">Buffer reader.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.Received.RemoteEndPoint">
            <summary>
            Gets endpoint that the message is from
            </summary>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.Received.BufferReader">
            <summary>
            Gets buffer with the received data
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.ReceivedInStream">
            <summary>
            Channel received more bytes in the stream
            </summary>
            <remarks>All streams used by this message support the <see cref="T:Griffin.Networking.Buffers.IPeekable"/> interface. </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.ReceivedInStream.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.ReceivedInStream"/> class.
            </summary>
            <param name="stream">Stream that received bytes were written to.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.ReceivedInStream.Stream">
            <summary>
            Gets stream that received bytes were written to
            </summary>
            <remarks>The stream is owned by the channel, do not dispose it</remarks>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.SendBuffer">
            <summary>
            Send a byte[] buffer
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.SendBuffer.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.SendBuffer"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">Offset in buffer.</param>
            <param name="count">Number of bytes to send.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.SendBuffer.Buffer">
            <summary>
            Gets buffer
            </summary>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.SendBuffer.Offset">
            <summary>
            Gets our starting offset
            </summary>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.SendBuffer.Count">
            <summary>
            Gets number of bytes to send
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.SendSlice">
            <summary>
            Send a slice 
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.SendSlice.#ctor(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.SendSlice"/> class.
            </summary>
            <param name="slice">The slice.</param>
            <param name="length">Number of bytes written to the slice.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.SendSlice.Slice">
            <summary>
            Gets buffer slice to send.
            </summary>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.SendSlice.Length">
            <summary>
            Gets number of bytes written to the slice
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.SendStream">
            <summary>
            Send an entire stream
            </summary>
            <remarks>
            Stream will be disposed by the framework
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.SendStream.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.SendStream"/> class.
            </summary>
            <param name="stream">Stream to send, the framework takes ownership.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.SendStream.Stream">
            <summary>
            Gets stream to send
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Messages.Sent">
            <summary>
            A message have been sent by the channel
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Messages.Sent.#ctor(Griffin.Networking.Buffers.BufferSlice)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.Messages.Sent"/> class.
            </summary>
            <param name="bufferSlice">The buffer slice.</param>
        </member>
        <member name="P:Griffin.Networking.Pipelines.Messages.Sent.BufferSlice">
            <summary>
            Gets the buffer slice.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.DelegatePipelineFactory">
            <summary>
            Uses delegates to created scoped handlers
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.DelegatePipelineFactory.Build">
            <summary>
            Create a pipeline for a channel
            </summary>
            <returns>Created pipeline</returns>
        </member>
        <member name="M:Griffin.Networking.Pipelines.DelegatePipelineFactory.AddDownstreamHandler(System.Func{Griffin.Networking.Pipelines.IDownstreamHandler})">
            <summary>
            Add another handler.
            </summary>
            <param name="factoryMethod">The factory method.</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.DelegatePipelineFactory.AddDownstreamHandler(Griffin.Networking.Pipelines.IDownstreamHandler)">
            <summary>
            Add an handler instance (singleton)
            </summary>
            <param name="handler">Must implement <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> and/or <see cref="T:Griffin.Networking.Pipelines.IUpstreamHandler"/></param>
            <remarks>Same instance will be used for all channels. Use the <see cref="T:Griffin.Networking.Pipelines.IPipelineHandlerContext"/> to store any context information.</remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.DelegatePipelineFactory.AddUpstreamHandler(System.Func{Griffin.Networking.Pipelines.IUpstreamHandler})">
            <summary>
            Add another handler.
            </summary>
            <param name="factoryMethod">The factory method.</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.DelegatePipelineFactory.AddUpstreamHandler(Griffin.Networking.Pipelines.IUpstreamHandler)">
            <summary>
            Add an handler instance (singleton)
            </summary>
            <param name="handler">Must implement <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> and/or <see cref="T:Griffin.Networking.Pipelines.IUpstreamHandler"/></param>
            <remarks>Same instance will be used for all channels. Use the <see cref="T:Griffin.Networking.Pipelines.IPipelineHandlerContext"/> to store any context information.</remarks>
        </member>
        <member name="T:Griffin.Networking.Pipelines.Pipeline">
            <summary>
            A pipeline is created for one channel only.
            </summary>
            <remarks>
              <para>
            Pipelines are used to transform the information recieved by the socket handler before
            it reaches the client. Same thing goes when the client want to send something through the channel.
              </para>
              <para>
            You MUST call <see cref="M:Griffin.Networking.Pipelines.Pipeline.SetChannel(Griffin.Networking.Pipelines.IDownstreamHandler)"/> before using the pipeline, since nothing till handle the messages otherwise (when all downstream handlers are finished).
              </para>
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Pipeline.HandleDownstream(Griffin.Networking.Pipelines.IPipelineHandlerContext,Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Process message
            </summary>
            <param name="context">Context information</param>
            <param name="message">Message to process</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Pipeline.SetChannel(Griffin.Networking.Pipelines.IDownstreamHandler)">
            <summary>
            Set down stream end point
            </summary>
            <param name="handler"> </param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Pipeline.SendDownstream(Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Send a message from the client and downwards.
            </summary>
            <param name="message">Message to send to the channel</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Pipeline.SendUpstream(Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Send something from the channel to all handlers.
            </summary>
            <param name="message">Message to send to the client</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Pipeline.AddDownstreamHandler(Griffin.Networking.Pipelines.IDownstreamHandler)">
            <summary>
            Add a new downstream handler 
            </summary>
            <param name="handler">Handler to add</param>
            <remarks>Downstream handlers takes care of everything sent from the client to the channel.</remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Pipeline.AddUpstreamHandler(Griffin.Networking.Pipelines.IUpstreamHandler)">
            <summary>
            Add a new upstream handler 
            </summary>
            <param name="handler">Handler to add</param>
            <remarks>Upstream handlers takes care of everything sent from the channel to the client.</remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.Pipeline.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Griffin.Networking.Pipelines.PipelineDownstreamContext">
            <summary>
            Context for a downstream (from channel to client) handler
            </summary>
        </member>
        <member name="T:Griffin.Networking.Pipelines.PipelineServer">
            <summary>
            Server that uses a pipeline for all client communication
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.PipelineServer.#ctor(Griffin.Networking.Pipelines.IPipelineFactory,Griffin.Networking.Servers.ServerConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.PipelineServer"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.PipelineServer.CreateClient(System.Net.EndPoint)">
            <summary>
            Create a new object which will handle all communication to/from a specific client.
            </summary>
            <param name="remoteEndPoint">Remote end point</param>
            <returns>Created client</returns>
        </member>
        <member name="T:Griffin.Networking.Pipelines.PipelineServerService">
            <summary>
            Takes care of everything from a specific client in the server.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Pipelines.PipelineServerService.#ctor(Griffin.Networking.Pipelines.IPipeline)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.PipelineServerService"/> class.
            </summary>
            <param name="pipeline">The pipeline.</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.PipelineServerService.HandleDownstream(Griffin.Networking.Pipelines.IPipelineHandlerContext,Griffin.Networking.Pipelines.IPipelineMessage)">
            <summary>
            Process message
            </summary>
            <param name="context"></param>
            <param name="message"></param>
            <remarks>
            Should always call either <see cref="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendDownstream(Griffin.Networking.Pipelines.IPipelineMessage)"/> or <see cref="M:Griffin.Networking.Pipelines.IPipelineHandlerContext.SendUpstream(Griffin.Networking.Pipelines.IPipelineMessage)"/>
            unless the handler really wants to stop the processing.
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.PipelineServerService.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.Pipelines.PipelineServerService.Assign(Griffin.Networking.Servers.IServerClientContext)">
            <summary>
            Assign the context which can be used to communicate with the client
            </summary>
            <param name="context">Context</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.PipelineServerService.HandleReceive(System.Object)">
            <summary>
            A new message have been received from the remote end.
            </summary>
            <param name="message"></param>
            <remarks>
            We'll deserialize messages for you. What you receive here depends on the used <see cref="T:Griffin.Networking.Messaging.IMessageFormatterFactory"/>.
            </remarks>
        </member>
        <member name="T:Griffin.Networking.Pipelines.PipelineUpstreamContext">
            <summary>
            Context for downstream handlers.
            </summary>
            <remarks>Each context is unique for a handler in a channel.</remarks>
        </member>
        <member name="T:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory">
            <summary>
            Uses a <see cref="T:Griffin.Networking.IServiceLocator"/> to build all handlers.
            </summary>
            <remarks>
            You must register all handlers in your service locator if the service locator can't build unregistered components.
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory.#ctor(Griffin.Networking.IServiceLocator)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory"/> class.
            </summary>
            <param name="serviceLocator">The service locator.</param>
        </member>
        <member name="M:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory.Build">
            <summary>
            Create a pipeline for a channel
            </summary>
            <returns>Created pipeline</returns>
        </member>
        <member name="M:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory.AddDownstreamHandler``1">
            <summary>
            Add another handler.
            </summary>
            <typeparam name="T">Handler type. Must implement <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> or <see cref="T:Griffin.Networking.Pipelines.IUpstreamHandler"/></typeparam>
        </member>
        <member name="M:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory.AddDownstreamHandler(Griffin.Networking.Pipelines.IDownstreamHandler)">
            <summary>
            Add an handler instance (singleton)
            </summary>
            <param name="handler">Must implement <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> and/or <see cref="T:Griffin.Networking.Pipelines.IUpstreamHandler"/></param>
            <remarks>Same instance will be used for all channels. Use the <see cref="T:Griffin.Networking.Pipelines.IPipelineHandlerContext"/> to store any context information.</remarks>
        </member>
        <member name="M:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory.AddUpstreamHandler``1">
            <summary>
            Add another handler.
            </summary>
            <typeparam name="T">Handler type. Must implement <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> or <see cref="T:Griffin.Networking.Pipelines.IUpstreamHandler"/></typeparam>
        </member>
        <member name="M:Griffin.Networking.Pipelines.ServiceLocatorPipelineFactory.AddUpstreamHandler(Griffin.Networking.Pipelines.IUpstreamHandler)">
            <summary>
            Add an handler instance (singleton)
            </summary>
            <param name="handler">Must implement <see cref="T:Griffin.Networking.Pipelines.IDownstreamHandler"/> and/or <see cref="T:Griffin.Networking.Pipelines.IUpstreamHandler"/></param>
            <remarks>Same instance will be used for all channels. Use the <see cref="T:Griffin.Networking.Pipelines.IPipelineHandlerContext"/> to store any context information.</remarks>
        </member>
        <member name="T:Griffin.Networking.Servers.ServerClientContext">
            <summary>
            Represents a client connection in the server.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Servers.IServerClientContext">
            <summary>
            Context used by application clients to be able to send stuff.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.IServerClientContext.Send(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Send something to the remote end point.
            </summary>
            <param name="slice">Buffer to send</param>
            <param name="count">Number of bytes that have actually been written to the buffer.</param>
        </member>
        <member name="M:Griffin.Networking.Servers.IServerClientContext.Send(System.IO.Stream)">
            <summary>
            Send a stream
            </summary>
            <param name="stream">Stream to send</param>
            <remarks>The stream will be owned by the framework, i.e. disposed when sent.</remarks>
        </member>
        <member name="M:Griffin.Networking.Servers.IServerClientContext.Close">
            <summary>
            Close connection and clean up.
            </summary>
        </member>
        <member name="P:Griffin.Networking.Servers.IServerClientContext.RemoteEndPoint">
            <summary>
            Gets address of the remote end point
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.#ctor(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Servers.ServerClientContext"/> class.
            </summary>
            <param name="readBuffer">The read buffer.</param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.Send(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Send information to the remote end point
            </summary>
            <param name="slice">Buffer slice</param>
            <param name="length">Number of bytes in the slice.</param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.Send(System.IO.Stream)">
            <summary>
            Send a stream
            </summary>
            <param name="stream">Stream to send</param>
            <remarks>The stream will be owned by the framework, i.e. disposed when sent.</remarks>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.Close">
            <summary>
            Close connection.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.TriggerDisconnect(System.Net.Sockets.SocketError)">
            <summary>
            Invoked when we have been disconnected
            </summary>
            <param name="error"><see cref="F:System.Net.Sockets.SocketError.Success"/> means that we called <see cref="M:Griffin.Networking.Servers.ServerClientContext.Close"/>.</param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.OnDisconnect(System.Net.Sockets.SocketError)">
            <summary>
            Invoked when we've been disconnected
            </summary>
            <param name="error"><see cref="F:System.Net.Sockets.SocketError.Success"/> means that we disconnected, all other codes indicates network failure or that the remote end point disconnected</param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.TriggerClientReceive(System.Object)">
            <summary>
            We've received information from the client
            </summary>
            <param name="data">The type of data depends on the server implementation.</param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.HandleRead(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Handle incoming bytes
            </summary>
            <param name="readBuffer">Buffer containing received bytes</param>
            <param name="bytesReceived">Number of bytes that was recieved (will always be set, any errors have triggered <see cref="M:Griffin.Networking.Servers.ServerClientContext.OnDisconnect(System.Net.Sockets.SocketError)"/> instead).</param>
            <remarks>
            <para>The default implementation will trigger the client with a <see cref="T:Griffin.Networking.Buffers.IBufferReader"/> as message. That means that
            you should not call the base method from your code.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.Assign(System.Net.Sockets.Socket,Griffin.Networking.Servers.IServerService)">
            <summary>
            Assign a new socket &amp; client to this context.
            </summary>
            <param name="socket">Socket that connected</param>
            <param name="client">Your own class dealing with this particular client.</param>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerClientContext.SetWriteBuffer(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Set buffer which can be used for the currently active write operation.
            </summary>
            <param name="bufferSlice">Slice</param>
        </member>
        <member name="P:Griffin.Networking.Servers.ServerClientContext.ReadBuffer">
            <summary>
            Our read buffer.
            </summary>
        </member>
        <member name="P:Griffin.Networking.Servers.ServerClientContext.RemoteEndPoint">
            <summary>
            Gets remote end point
            </summary>
        </member>
        <member name="E:Griffin.Networking.Servers.ServerClientContext.Disconnected">
            <summary>
            Remote side have disconnected (or network failure)
            </summary>
            <remarks><para>The source will be the context.</para><para>Will also be triggered when <see cref="M:Griffin.Networking.Servers.ServerClientContext.Close"/> is invoked, but with the error code <see cref="F:System.Net.Sockets.SocketError.Success"/>.</para></remarks>
        </member>
        <member name="T:Griffin.Networking.Servers.IServiceFactory">
            <summary>
            Used to create the client (i.e. your class that handles a connection from a client)
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.IServiceFactory.CreateClient(System.Net.EndPoint)">
            <summary>
            Create a new client
            </summary>
            <param name="remoteEndPoint">IP address of the remote end point</param>
            <returns>Created client</returns>
        </member>
        <member name="T:Griffin.Networking.Messaging.MessagingClientContext">
            <summary>
            Used by <see cref="T:Griffin.Networking.Messaging.MessagingServer"/>.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingClientContext.#ctor(Griffin.Networking.Buffers.IBufferSlice,Griffin.Networking.Messaging.IMessageFormatterFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Messaging.MessagingClientContext"/> class.
            </summary>
            <param name="readBuffer">The read buffer.</param>
            <param name="formatterFactory">Used to format messages </param>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingClientContext.HandleRead(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Handles the read.
            </summary>
            <param name="slice">The slice.</param>
            <param name="bytesRead">The bytes read.</param>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingClientContext.Write(System.Object)">
            <summary>
            Will serialize messages
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Griffin.Networking.Messaging.MessagingServerConfiguration">
            <summary>
            Configuration for <see cref="T:Griffin.Networking.Messaging.MessagingServer"/>.
            </summary>
        </member>
        <member name="T:Griffin.Networking.Servers.ServerConfiguration">
            <summary>
            Configures the server
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerConfiguration.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Servers.ServerConfiguration"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Networking.Servers.ServerConfiguration.Validate">
            <summary>
            Validate that the configuration is correct and that it contains all required information
            </summary>
        </member>
        <member name="P:Griffin.Networking.Servers.ServerConfiguration.MaximumNumberOfClients">
            <summary>
            Gets or sets the maximum number of clients that can be connected simultaneously
            </summary>
            <value>Default = 100</value>
        </member>
        <member name="P:Griffin.Networking.Servers.ServerConfiguration.BufferSize">
            <summary>
            Gets or sets the size of the buffers should when sending/receiving data.
            </summary>
            <remarks>Too small buffers can make the selected <see cref="T:Griffin.Networking.Messaging.IMessageFormatterFactory"/> fail when serializing/deserializing messages.</remarks>
            <value>Default = 65535</value>
        </member>
        <member name="P:Griffin.Networking.Servers.ServerConfiguration.BufferSliceStack">
            <summary>
            Gets or sets stack used 
            </summary>
        </member>
        <member name="M:Griffin.Networking.Messaging.MessagingServerConfiguration.#ctor(Griffin.Networking.Messaging.IMessageFormatterFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.Servers.ServerConfiguration"/> class.
            </summary>
            <param name="messageFormatterFactory">The message formatter factory.</param>
            <seealso cref="P:Griffin.Networking.Messaging.MessagingServerConfiguration.MessageFormatterFactory"/>
        </member>
        <member name="P:Griffin.Networking.Messaging.MessagingServerConfiguration.MessageFormatterFactory">
            <summary>
            Used to serialize/build the messages that are transferred.
            </summary>
        </member>
        <member name="T:Griffin.Networking.SliceSocketWriterJob">
            <summary>
            Writes a buffer slice to the socket.
            </summary>
            <remarks>Make sure that the entire slice fits the Sockets internal buffer.</remarks>
        </member>
        <member name="M:Griffin.Networking.SliceSocketWriterJob.#ctor(Griffin.Networking.Buffers.IBufferSlice,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.SliceSocketWriterJob"/> class.
            </summary>
            <param name="slice">Slice to send.</param>
            <param name="count">Number of bytes in the slice.</param>
        </member>
        <member name="M:Griffin.Networking.SliceSocketWriterJob.Write(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Write stuff to our args.
            </summary>
            <param name="args">Args used when sending bytes to the socket</param>
        </member>
        <member name="M:Griffin.Networking.SliceSocketWriterJob.WriteCompleted(System.Int32)">
            <summary>
            The async write has been completed
            </summary>
            <param name="bytes">Number of bytes that was sent</param>
            <returns>
              <c>true</c> if everything was sent; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Griffin.Networking.SliceSocketWriterJob.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.SliceSocketWriterJob.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:Griffin.Networking.SocketWriter">
            <summary>
            Used to write information to a socket in a queued fashion.
            </summary>
        </member>
        <member name="M:Griffin.Networking.SocketWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.SocketWriter"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Networking.SocketWriter.Assign(System.Net.Sockets.Socket)">
            <summary>
            Assign socket which will be used for writing.
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:Griffin.Networking.SocketWriter.Send(Griffin.Networking.ISocketWriterJob)">
            <summary>
            Sends the specified slice.
            </summary>
            <exception cref="T:System.ArgumentNullException">slice</exception>
            <exception cref="T:System.InvalidOperationException">Socket as not been Assign():ed.</exception>
            <seealso cref="T:Griffin.Networking.StreamSocketWriterJob"/>
            <seealso cref="T:Griffin.Networking.SliceSocketWriterJob"/>
        </member>
        <member name="M:Griffin.Networking.SocketWriter.Reset">
            <summary>
            Reset writer.
            </summary>
        </member>
        <member name="M:Griffin.Networking.SocketWriter.SetBuffer(Griffin.Networking.Buffers.IBufferSlice)">
            <summary>
            Assign a buffer which can be used during writes.
            </summary>
            <param name="bufferSlice">Buffer</param>
            <remarks>The buffer is stored as <c>UserToken</c> for the AsyncEventArgs. Do not change the token, but feel free to use it for the current write.</remarks>
        </member>
        <member name="E:Griffin.Networking.SocketWriter.Disconnected">
            <summary>
            We've been disconnected (detected during a write)
            </summary>
        </member>
        <member name="T:Griffin.Networking.StreamSocketWriterJob">
            <summary>
            Send a stream to the socket.
            </summary>
            <remarks>Large stream will be send a bit at a time.</remarks>
        </member>
        <member name="M:Griffin.Networking.StreamSocketWriterJob.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Networking.StreamSocketWriterJob"/> class.
            </summary>
            <param name="stream">The stream, owned by this class (i.e. being disposed when sent).</param>
            <exception cref="T:System.ArgumentNullException">stream</exception>
        </member>
        <member name="M:Griffin.Networking.StreamSocketWriterJob.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Networking.StreamSocketWriterJob.Write(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Write stuff to our args.
            </summary>
            <param name="args">Args used when sending bytes to the socket</param>
        </member>
        <member name="M:Griffin.Networking.StreamSocketWriterJob.WriteCompleted(System.Int32)">
            <summary>
            The async write has been completed
            </summary>
            <param name="bytes">Number of bytes that was sent</param>
            <returns><c>true</c> if everything was sent; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Griffin.Networking.StreamSocketWriterJob.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
    </members>
</doc>
